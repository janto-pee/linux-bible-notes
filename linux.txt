CHAPTER 1 - Starting with Linux Shells

First, four main parts make up a Linux system:
■ The Linux kernel
■ The GNU utilities
■ A graphical desktop environment
■ Application software
Each of these parts has a specifi c job in the Linux system. No part is very useful by itself. 


i)  THE LINUX KERNEL
The core of the Linux system is the kernel. The kernel controls all the hardware and software on the computer system, allocating hardware when necessary and executing software
when required.
The kernel is primarily responsible for four main functions:
■ System memory management
■ Software program management
■ Hardware management
■ Filesystem management
The following sections explore each of these functions in more detail.

System Memory Management
One of the primary functions of the operating system kernel is memory management. Not
only does the kernel manage the physical memory available on the server, but it can also
create and manage virtual memory, or memory that does not actually exist.
It does this by using space on the hard disk, called the swap space. The kernel swaps the
contents of virtual memory locations back and forth from the swap space to the actual
physical memory. This allows the system to think there is more memory available than
what physically exists,

Software Program Management
The Linux operating system calls a running program a process. A process can run in the
foreground, displaying output on a display, or it can run in the background, behind the
scenes. The kernel controls how the Linux system manages all the processes running on the
system.
The kernel creates the fi rst process, called the init process, to start all other processes on the
system. When the kernel starts, it loads the init process into virtual memory. As the kernel
starts each additional process, it gives it a unique area in virtual memory to store the data
and code that the process uses.

Hardware Management
Any device that the Linux system must communicate with needs driver code inserted inside the kernel code.
The driver code allows the kernel to pass data back and forth to the device, acting as a
middle man between applications and the hardware. Two methods are used for inserting
device driver code in the Linux kernel:
■ Drivers compiled in the kernel
■ Driver modules added to the kernel
Previously, the only way to insert device driver code was to recompile the kernel. Each time
you added a new device to the system, you had to recompile the kernel code. This process
became even more ineffi cient as Linux kernels supported more hardware. Fortunately,
Linux developers devised a better method to insert driver code into the running kernel.
Programmers developed the concept of kernel modules to allow you to insert driver code
into a running kernel without having to recompile the kernel. Also, a kernel module could
be removed from the kernel when the device was fi nished being used. This greatly simplifi ed and expanded using hardware with Linux.
The Linux system identifi es hardware devices as special fi les, called device files. There are
three classifi cations of device fi les:
■ Character
■ Block
■ Network

Filesystem Management
Unlike some other operating systems, the Linux kernel can support different types of
fi lesystems to read and write data to and from hard drives. Besides having over a dozen
fi lesystems of its own, Linux can read and write to and from fi lesystems used by other
operating systems, such as Microsoft Windows. The kernel must be compiled with support
for all types of fi lesystems that the system will use. 
Any hard drive that a Linux server accesses must be formatted using one of the fi lesystem
types
The Linux kernel interfaces with each fi lesystem using the Virtual File System (VFS). This
provides a standard interface for the kernel to communicate with any type of fi lesystem.
VFS caches information in memory as each fi lesystem is mounted and used.

ii) THE GNU utilities
Besides having a kernel to control hardware devices, a computer operating system needs
utilities to perform standard functions, such as controlling fi les and programs.
The core bundle of utilities supplied for Linux systems is
called the coreutils package.
The GNU coreutils package consists of three parts:
■ Utilities for handling fi les
■ Utilities for manipulating text
■ Utilities for managing processes
Each of these three main groups of utilities contains several utility programs that are
invaluable to the Linux system administrator and programmer

a)  The Shell
The GNU/Linux shell is a special interactive utility. It provides a way for users to start programs, manage fi les on the filesystem, and manage processes running on the Linux system.
The core of the shell is the command prompt. The command prompt is the interactive part
of the shell. It allows you to enter text commands, and then it interprets the commands
and executes them in the kernel.
The shell contains a set of internal commands that you use to control things such as copying fi les, moving files, renaming files, displaying the programs currently running on the
system, and stopping programs running on the system. Besides the internal commands,
the shell also allows you to enter the name of a program at the command prompt. The shell
passes the program name off to the kernel to start it.
You can also group shell commands into fi les to execute as a program. Those fi les are called
shell scripts. Any command that you can execute from the command line can be placed in
a shell script and run as a group of commands. This provides great fl exibility in creating
utilities for commonly run commands, or processes that require several commands grouped
together.
There are quite a few Linux shells available to use on a Linux system. Different shells have
different characteristics, some being more useful for creating scripts and some being more
useful for managing processes. The default shell used in all Linux distributions is the bash
shell. The bash shell was developed by the GNU project as a replacement for the standard
Unix shell, called the Bourne shell (after its creator). The bash shell name is a play on this
wording, referred to as the “Bourne again shell.”
Most Linux distributions include more than one shell, although usually they pick one of
them to be the default. If your Linux distribution includes multiple shells, feel free to
experiment with different shells and see which one fi ts your needs.


The Linux Desktop Environment
In the early days of Linux (the early 1990s) all that was available was a simple text interface to the Linux operating system. This text interface allowed administrators to start programs, control program operations, and move fi les around on the system.
With the popularity of Microsoft Windows, computer users expected more than the old text
interface to work with. This spurred more development in the OSS community, and the
Linux graphical desktops emerged.

Linux Distributions
A complete Linux system package is called a distribution. Many different Linux distributions
are available to meet just about any computing requirement you could have. Most distributions are customized for a specifi c user group, such as business users, multimedia enthusiasts, software developers, or average home users. Each customized distribution includes
the software packages required to support specialized functions, such as audio- and videoediting software for multimedia enthusiasts, or compilers and integrated development environments (IDEs) for software developers.
The different Linux distributions are often divided into three categories:
■ Full core Linux distributions
■ Specialized distributions
■ LiveCD test distributions
The following sections describe these different types of Linux distributions and show some
examples of Linux distributions in each category

a)  Core Linux Distributions
A core Linux distribution contains a kernel, one or more graphical desktop environments,
and just about every Linux application that is available, precompiled for the kernel. It
provides one-stop shopping for a complete Linux installation
e.g RedHat, Fedora, slackware, debian

b)  Specialized Linux Distributions
A new subgroup of Linux distributions has started to appear. These are typically based on
one of the main distributions but contain only a subset of applications that would make
sense for a specifi c area of use.
In addition to providing specialized software (such as only offi ce products for business
users), customized Linux distributions also attempt to help beginning Linux users by
TABLE 1-4 (continued)
19
Chapter 1: Starting with Linux Shells
1
autodetecting and autoconfi guring common hardware devices. This makes installing Linux
a much more enjoyable process.
e.g CentOs, Ubuntu, Mint, Puppy Linux


c)  The Linux LiveCD
A relatively new phenomenon in the Linux world is the bootable Linux CD distribution.
This lets you see what a Linux system is like without actually installing it. Most modern
PCs can boot from a CD instead of the standard hard drive. To take advantage of this, some
Linux distributions create a bootable CD that contains a sample Linux system (called a Linux
LiveCD). Because of the limitations of the single CD size, the sample can’t contain a complete
Linux system, but you’d be surprised at all the software they can cram in there. The result
is that you can boot your PC from the CD and run a Linux distribution without having to
install anything on your hard drive!
e.g Ubuntu, Slax, Puppy linux
As with all good things, Linux LiveCDs have a few drawbacks. Because you access everything from the CD, applications run more slowly, especially if you’re using older, slower
computers and CD drives. Also, because you can’t write to the CD, any changes you make to
the Linux system will be gone the next time you reboot.
But advances are being made in the Linux LiveCD world that will help to solve some of
these problems. These advances include the ability to:
■ Copy Linux system fi les from the CD to memory
■ Copy system fi les to a fi le on the hard drive
■ Store system settings on a USB memory stick
■ Store user settings on a USB memory stick


=============================================================================================================


CHAPTER 2
In the old days of Linux, all you had to work with was the shell. System administrators, programmers, and system users all sat at something called a Linux console terminal entering shell
commands and viewing text output. These days, with graphical desktop environments, it’s getting harder to fi nd a shell prompt on the system in order to enter shell commands. This chapter
discusses what is required to reach a command line environment.

Before the days of graphical desktops, the only way to interact with a Unix system was through a
text command line interface (CLI) provided by the shell. The CLI allowed text input only and could
display only text and rudimentary graphics output.
As you well know, things are signifi cantly different in today’s Linux environment. Just about every
Linux distribution uses some type of graphical desktop environment. However, to enter shell commands, you still need a text display to access the shell’s CLI. The problem now is getting to one.
Sometimes fi nding a way to get a CLI in a Linux distribution is not an easy task.


a) Console Terminals
One way to get to a CLI is to take the Linux system out of graphical desktop mode and
place it in text mode. This provides nothing more than a simple shell CLI on the monitor,
just like the days before graphical desktops. This mode is called the Linux console because
it emulates the old days of a hard-wired console terminal and is a direct interface to the
Linux system.
When the Linux system starts, it automatically creates several virtual consoles. A virtual
console is a terminal session that runs in Linux system memory. Instead of having several
dumb terminals connected to the computer, most Linux distributions start fi ve or six (or
sometimes even more) virtual consoles that you can access from a single computer keyboard
and monitor.

b) Graphical Terminals
The alternative to using a virtual console terminal is to use a terminal emulation
package from within the Linux graphical desktop environment. A terminal emulation
package simulates working on a console terminal, but within a desktop graphical window. 

i)  Accessing CLI via a Linux Console Terminal
In the early days of Linux, when you booted up your system you would see a login prompt
on your monitor, and that’s all. As mentioned earlier, this is called the Linux console. It
was the only place you could enter commands for the system.
Even though several virtual consoles are created at boot time, many Linux distributions
switch to a graphical environment after the boot sequence completes. This provides the
user with a graphical login and desktop experience. Therefore, in this case, accessing a virtual console is done manually

ii) Accessing CLI via Graphical Terminal Emulation
The graphical desktop environment offers a great deal more variety for CLI access than the
virtual console terminal does. Many graphical terminal emulator packages are available
for the graphical environment. Each package provides its own unique set of features and
options. 

iii)    Using the GNOME Terminal Emulator
GNOME Terminal is the GNOME desktop environment’s default terminal emulator. Many
distributions, such as RHEL, Fedora, and CentOS, use the GNOME desktop environment by

default, and therefore use GNOME Terminal by default. However, other desktop environments, such as Ubuntu Unity, also use the GNOME terminal as their default terminal emulator package. It is fairly easy to use and a good terminal emulator for individuals who are
new to Linux.
In the GNOME desktop environment, accessing the GNOME Terminal is fairly straightforward. From the menu system in the upper-left corner of the window, click Applications,
then select System Tools from the drop-down menu, and fi nally click Terminal


iii)    Using the Konsole Terminal Emulator
The KDE Desktop Project created its own terminal emulation package called Konsole
Terminal. The Konsole package incorporates basic terminal emulation features, along with
more advanced ones expected from a graphical application
The Konsole Terminal is the default terminal emulator for the KDE desktop environment.
You can easily access it via the KDE environment’s menu system. 

iv) Using the xterm Terminal Emulator
The oldest and most basic of terminal emulation packages is xterm. The xterm package has
been around since before the original days of X Window, a popular display server, and it’s
often included by default in distributions.
Although xterm is a full terminal emulation package, it doesn’t require many resources
(such as memory) to operate. Because of this, the xterm package is still popular in Linux
distributions designed to run on older hardware. Some graphical desktop environments use
it as the default terminal emulation package.
Although it doesn’t offer many fancy features, the xterm package does one thing extremely
well: It emulates older terminals, such as the Digital Equipment Corporation (DEC) VT102,
VT220, and Tektronix 4014 terminals. 


=============================================================================================================


CHAPTER 3 - Basic bash Shell Commands
The default shell used in many Linux distributions is the GNU bash shell. This chapter describes
the basic features available in the bash shell, such as the bash manual, tab auto-completion
and how to display a fi le’s contents

The GNU bash shell is a program that provides interactive access to the Linux system. It runs as a
regular program and is normally started whenever a user logs in to a terminal. The shell that the
system starts depends on your user ID confi guration.
The /etc/passwd fi le contains a list of all the system user accounts, along with some basic confi guration information about each user. Here’s a sample entry from a /etc/passwd fi le:
christine:x:501:501:Christine Bresnahan:/home/christine:/bin/bash
Each entry has seven data fi elds, with fi elds separated by colons. The system uses the data in these
fi elds to assign specifi c features for the user

In the earlier /etc/passwd sample entry, the user christine has /bin/bash set as her
default shell program. This means when christine logs into the Linux system, the bash
shell program is automatically started.

Although the bash shell program is automatically started at login, whether a shell command line interface (CLI) is presented depends on which login method is used. If a virtual
console terminal is used to log in, the CLI prompt is automatically presented, and you can
begin to type shell commands. However, if you log into the Linux system via a graphical
desktop environment, you need to start a graphical terminal emulator to access the shell
CLI prompt.

The default prompt symbol for the bash shell is the dollar sign.This symbol indicates
that the shell is waiting for you to enter text


a)  Interacting with the bash Manual
Most Linux distributions include an online manual for looking up information on shell
commands, as well as lots of other GNU utilities included in the distribution. You should
become familiar with the manual, because it’s invaluable for working with commands, especially when you’re trying to fi gure out various command line parameters.
The man command provides access to the manual pages stored on the Linux system.
Entering the man command followed by a specifi c command name provides that utility’s
manual entry.

When you use the man command to view a command’s manual pages, they are displayed
with something called a pager. A pager is a utility that allows you to page through
displayed text. Thus, you can page through the man pages by pressing the spacebar, or you
can go line by line using the Enter key. In addition, you can use the arrow keys to scroll
forward and backward through the man page text (assuming that your terminal emulation
package supports the arrow key functions).
When you are fi nished with the man pages, press the q key to quit. When you quit the man
pages, you receive a shell CLI prompt, indicating the shell is waiting for your next command.

In addition, most commands accept the -help or --help option. For example, you can
type hostname -help to see a help screen.


b) Looking at the Linux fi lesystem

The fi rst difference you’ll notice is that Linux does not use drive letters in pathnames. In
the Windows world, the physical drives installed on the computer determine the pathname
53
Chapter 3: Basic bash Shell Commands
3
of the fi le. Windows assigns a letter to each physical disk drive, and each drive contains its
own directory structure for accessing fi les stored on it.
For example, in Windows you may be used to seeing the fi le paths such as:
c:\Users\Rich\Documents\test.doc
The Windows fi le path tells you exactly which physical disk partition contains the fi le
named test.doc. For example, if you saved test.doc on a fl ash drive, designated by the
J drive, the fi le path would be J:\test.doc. This path indicates that the fi le is located at
the root of the drive assigned the letter J.
This is not the method used by Linux. Linux stores fi les within a single directory structure, called a virtual directory. The virtual directory contains fi le paths from all the storage
devices installed on the computer, merged into a single directory structure.
The Linux virtual directory structure contains a single base directory, called the root.
Directories and fi les beneath the root directory are listed based on the directory path used
to get to them, similar to the way Windows does it.

In Linux, you will see fi le paths similar to the following:
/home/Rich/Documents/test.doc
This indicates the fi le test.doc is in the directory Documents, under the directory rich,
which is contained in the directory home. Notice that the path doesn’t provide any information as to which physical disk the fi le is stored on.
The tricky part about the Linux virtual directory is how it incorporates each storage device.
The fi rst hard drive installed in a Linux system is called the root drive. The root drive contains the virtual directory core. Everything else builds from there.
On the root drive, Linux can use special directories as mount points. Mount points are
directories in the virtual directory where you can assign additional storage devices. Linux
causes fi les and directories to appear within these mount point directories, even though
they are physically stored on a different drive.

(page 54) One hard drive is associated with the
root of the virtual directory (indicated by a single forward slash). Other hard drives can
be mounted anywhere in the virtual directory structure. In this example, the second hard
drive is mounted at the location /home, which is where the user directories are located.

When you log in to your system and reach a shell CLI prompt, your session starts in your
home directory. Your home directory is a unique directory assigned to your user account.
When a user account is created, the system normally assigns a unique directory for the
account (see Chapter 7).
You can move around the virtual directory using a graphical interface. However, to move
around the virtual directory from a CLI prompt, you need to learn to use the cd command

i)  Traversing directories ==== cd ==== move your shell session to another directory
in the Linux fi lesystem ===== cd destination.
The destination parameter can be expressed using two different methods. 
    a)  absolute directory reference =  The absolute directory reference defi nes exactly where the directory  is in the virtual directory structure, starting at the root.
    An absolute directory reference always begins with a forward slash (/), indicating the virtual directory system’s root
     cd /usr/bin
     You can move to any level within the entire Linux virtual directory structure from any
    level using the absolute directory reference:
    You can also quickly jump to your home directory from any level within the Linux virtual
    directory structure ==== cd
    b)  relative directory reference.
    Relative directory references allow you to specify a destination directory reference relative to
    your current location. A relative directory reference doesn’t start with a forward slash (/).
    For example, if you
    are in your home directory and want to move to your Documents subdirectory, you can use
    the cd command along with a relative directory reference:
    cd Documents ==== no forward slash

    You can use a relative directory reference with the cd command in any directory containing subdirectories. You can also use a special character to indicate a relative directory
    location.
    The two special characters used for relative directory references are:
    ■ The single dot (.) to represent the current directory
    ■ The double dot (..) to represent the parent directory
    cd ../Downloads
    The double dot character takes you back up one level to your home directory
    cd ../../etc

    The pwd command
    displays the shell session’s current directory location, which is called the present working directory


ii) Listing Files and Directories
To see what fi les are available on the system, use the list command (ls).
Displaying a basic listing ==== ls
If you don’t have a color terminal emulator, you can use the -F parameter with the ls
command to easily distinguish fi les from directories. ls -F

The basic ls command can be somewhat misleading. It shows the fi les and directories
contained in the current directory, but not necessarily all of them. Linux often uses
hidden fi les to store confi guration information. In Linux, hidden fi les are fi les with
fi lenames starting with a period (.)
$ ls -a             All the fi les beginning with a period, hidden fi les, are now shown.

The -R parameter is another option the ls command can use. Called the recursive option,
it shows fi les that are contained within subdirectories in the current directory.
$ ls -F -R

Displaying a long listing, For listing additional information, another popular parameter is -l ==== $ ls -l 
drwxr-xr-x 2 christine christine 4096 Apr 22 20:37 Desktop

After that, each line contains the following information about each fi le (or directory):
■ The fi le type — such as directory (d), fi le (-), linked fi le (l), character device (c),
or block device (b)
■ The fi le permissions (see Chapter 6)
■ The number of fi le hard links (See the section “Linking Files” in Chapter 7.)
■ The fi le owner username
■ The fi le primary group name
■ The fi le byte size
■ The last time the fi le was modifi ed
■ The fi lename or directory name

Filtering listing output ==== $ ls -l my_script
The ls command also recognizes standard wildcard characters and uses them to match
patterns within the fi lter:
■ A question mark (?) to represent one character
■ An asterisk (*) to represent any number of characters
The question mark can be used to replace exactly one character anywhere in the fi lter
string. For example:
$ ls -l my_scr?pt
The fi lter my_scr?pt matched two fi les in the directory. Similarly, the asterisk can be used
to match zero or more characters:
$ ls -l my*

Using the asterisk and question mark in the fi lter is called fi le globbing. File globbing is the
processing of pattern matching using wildcards. The wildcards are offi cially called
metacharacter wildcards. You can use more metacharacter wildcards for fi le globbing than
just the asterisk and question mark. You can also use brackets:
$ ls -l my_scr[ai]pt

The brackets represent a single character position and give you multiple options for fi le globbing. You can list choices of characters, as shown in the preceding
example, and you can specify a range of characters, such as an alphabetic range [a - i]:
$ ls -l f[a-i]ll

Also, you can specify what should not be included in the pattern match by using the exclamation point (!):
$ ls -l f[!a]ll


Handling Files
The shell provides many fi le manipulation commands on the Linux fi lesystem. This section
walks you through the basic shell commands you need to handle fi les.
Creating fi les $ touch test_one   
$ ls -l test_one

The touch command can also be used to change the modifi cation time. This is done without changing the fi le contents:
$ touch test_one
$ ls -l test_one
The modifi cation time of test_one is now updated

To change only the access time, use the -a parameter with the touch command: $ touch -a test_one

In the preceding example, notice that by using only the ls -l command, the access time
does not display. This is because the modifi cation time is shown by default. To see a fi le’s
access time, you need to add an additional parameter, --time=atime. After we add that
parameter in the preceding example, the fi le’s altered access time is displayed: $ ls -l --time=atime test_one

Copying fi les
Copying fi les and directories from one location in the fi lesystem to another is a common
practice for system administrators. The cp command provides this feature.
In its most basic form, the cp command uses two parameters — the source object and the
destination object: cp source destination.
When both the source and destination parameters are fi lenames, the cp command
copies the source fi le to a new destination fi le. The new fi le acts like a brand new fi le, with
an updated modifi cation time:
$ cp test_one test_two
$ ls -l test_*


The new fi le test_two shows a different modifi cation time than the test_one fi le. If the
destination fi le already exists, the cp command may not prompt you to this fact. It is best
to add the -i option to force the shell to ask whether you want to overwrite a fi le:
$ ls -l test_*
-rw-rw-r-- 1 christine christine 0 May 21 14:35 test_one
-rw-rw-r-- 1 christine christine 0 May 21 15:15 test_two
$
$ cp -i test_one test_two
cp: overwrite 'test_two'? n
$
If you don’t answer y, the fi le copy does not proceed. You can also copy a fi le into a
pre-existing directory:  $ cp -i test_one /home/christine/Documents/
you can just as easily use a relative directory reference:
$ cp -i test_one Documents/
$ cp -i /etc/NetworkManager/NetworkManager.conf . //(.) represent present working directory

The -R parameter is a powerful cp command option. It allows you to recursively copy the
contents of an entire directory in one command:
$ ls -Fd *Scripts
Scripts/
$ ls -l Scripts/

$ cp -R Scripts/ Mod_Scripts
$ ls -Fd *Scripts
Mod_Scripts/ Scripts/
$ ls -l Mod_Scripts

The directory Mod_Scripts did not exist prior to the cp -R command. It was created
with the cp -R command, and the entire Scripts directory’s contents were copied into
it

You can also use wildcard metacharacters in your cp commands:
$ cp *script Mod_Scripts/
This command copied any fi les that ended with script to Mod_Scripts


Using tab auto-complete
tab auto-complete can be a lifesaver
$ ls really*
$ cp really_ridiculously_long_file_name Mod_Scripts/


Linking fi les
Linking fi les is a great option available in the Linux fi lesystem. If you need to maintain
two (or more) copies of the same fi le on the system, instead of having separate physical
copies, you can use one physical copy and multiple virtual copies, called links. A link is a
placeholder in a directory that points to the real location of the fi le. Two types of fi le links
are available in Linux:
■ A symbolic link
■ A hard link

$ ln -s data_file sl_data_file
$ ls -l *data_file
notice that the name of the symbolic link, sl_data_file, is
listed second in the ln command
Also note the symbolic link’s fi le size versus the data fi le’s fi le size. The symbolic link,
sl_data_file, is only 9 bytes, whereas the data_file is 1092 bytes
This is because
sl_data_file is only pointing to data_file. They do not share contents and are two
physically separate fi les.

Another way to tell that these linked fi les are separate physical fi les is by viewing their
inode number. The inode number of a fi le or directory is a unique identifi cation number
that the kernel assigns to each object in the fi lesystem. To view a fi le or directory’s inode
number, add the -i parameter to the ls command:
$ ls -i *data_file

The example shows that the data fi le’s inode number is 296890, while the sl_data_file
inode number is different. It is 296891

A hard link creates a separate virtual fi le that contains information about the original fi le
and where to locate it.
However, they are physically the same fi le. When you reference the
hard link fi le, it’s just as if you’re referencing the original fi le
To create a hard link, again
the original fi le must pre-exist, except that this time no parameter is needed on the ln
command:

$ ls -l code_file
$ ln code_file hl_code_file
$ ls -li *code_file
 we used the ls -li command to show both the inode numbers
and a long listing for the *code_files. Notice that both fi les, which are hard linked
together, share the name inode number. This is because they are physically the same fi le.
Also notice that the link count (the third item in the listing) now shows that both fi les
have two links. In addition, their fi le size is exactly the same size as well

Be careful when copying linked fi les. If you use the cp command to copy a fi le that’s linked
to another source fi le, all you’re doing is making another copy of the source fi le. This can
quickly get confusing. Instead of copying the linked fi le, you can create another link to the
original fi le. You can have many links to the same fi le with no problems. However, you also
don’t want to create soft links to other soft-linked fi les. This creates a chain of links that
can be confusing — and easily broken — causing all sorts of problems.


Renaming fi les
In the Linux world, renaming fi les is called moving files.
$ ls -li f?ll

$ mv fall fzll
$
$ ls -li f?ll

Notice that moving the fi le changed the name from fall to fzll, but it kept the same
inode number and timestamp value. This is because mv affects only a fi le’s name.
You can also use mv to change a fi le’s location:
$ ls -li /home/christine/fzll
296730 -rw-rw-r-- 1 christine christine 0 May 21 13:44
/home/christine/fzll
$ ls -li /home/christine/Pictures/
$ mv fzll Pictures/
$ ls -li /home/christine/Pictures/
$ ls -li /home/christine/fzll

You can use the mv command to move a fi le’s location and rename it, all in one easy step:
$ ls -li Pictures/fzll
$ mv /home/christine/Pictures/fzll /home/christine/fall
$ ls -li /home/christine/fall
$ ls -li /home/christine/Pictures/fzll

You can also use the mv command to move entire directories and their contents:
$ ls -li Mod_Scripts
$ mv Mod_Scripts Old_Scripts
$ ls -li Mod_Scripts
$ ls -li Old_Scripts

The directory’s entire contents are unchanged. The only thing that changes is the name of
the directory. 


Deleting fi les
In the Linux world, deleting is called removing
$ rm -i fall
$ ls -l fall
$ rm -i f?ll
$ ls -l f?ll

Managing Directories

Creating directories
Creating a new directory in Linux is easy — just use the mkdir command:
$ mkdir New_Dir
$ ls -ld New_Dir

To create several directories and subdirectories at the same time, you need to add the -p
parameter:
$ mkdir -p New_Dir/Sub_Dir/Under_Dir
$
$ ls -R New_Dir

The -p option on the mkdir command makes any missing parent directories as needed.

$ rmdir New_Dir
rmdir: failed to remove 'New_Dir': Directory not empty
By default, the rmdir command works only for removing empty directories. 

$ rm -i New_Dir/my_file
rm: remove regular empty file 'New_Dir/my_file'? y
$
$ rmdir New_Dir
$
$ ls -ld New_Dir


You can also use the rm command on entire non-empty directories. Using the -r option
allows the command to descend into the directory, remove the fi les, and then remove the
directory itself:
$ ls -l My_Dir
total 0
-rw-rw-r-- 1 christine christine 0 May 22 10:02 another_file
$
$ rm -ri My_Dir
rm: descend into directory 'My_Dir'? y
rm: remove regular empty file 'My_Dir/another_file'? y
rm: remove directory 'My_Dir'? y
$
$ ls -l My_Dir
ls: cannot access My_Dir: No such file or directory
$
This also works for descending into multiple subdirectories and is especially useful when
you have lots of directories and fi les to delete:
$ ls -FR Small_Dir
Small_Dir:
a_file b_file c_file Teeny_Dir/ Tiny_Dir/
Small_Dir/Teeny_Dir:
e_file
Small_Dir/Tiny_Dir:
d_file
$
$ rm -ir Small_Dir

The ultimate solution for throwing caution to the wind and removing an entire directory,
contents and all, is 
$ rm -rf Small_Dir
The rm -rf command gives no warnings and no fanfare

Viewing the fi le type
$ file my_file
$ file New_Dir
$ file sl_data_file:  shows a fi le, which is a symbolic link.
$ file my_script: returns for a script fi le
$ file /bin/ls: is a binary executable program

Viewing the whole fi le
If you have a large text fi le on your hands, you may want to be able to see what’s inside of
it. Linux has three different commands that can help you here.

Using the cat command
The cat command is a handy tool for displaying all the data inside a text fi le:
$ cat test1
$ cat -n test1: The -n parameter numbers all the lines for you

If you just want to number the lines that have text in them, the -b parameter is for you:
$ cat -b test1

Finally, if you don’t want tab characters to appear, use the -T parameter:
$ cat -T test1

For large fi les, the cat command can be somewhat annoying. The text in the fi le just
quickly scrolls off the display without stopping. Fortunately, we have a simple way to solve
this problem.

Using the more command
 more /etc/bash.bashrc
 Using the less command

 Viewing parts of a fi le
Often the data you want to view is located either right at the top or buried at the bottom
of a text fi le. 
Using the tail command
$ tail log_file
$ tail -n 2 log_file: You can change the number of lines shown using tail by including the -n parameter. In
this example, only the last two lines of the fi le are displayed, by adding -n 2 to the tail
command:

Using the head command
The head command does what you’d expect; it displays a fi le’s fi rst group of lines (the fi le’s
“head”). By default, it displays the fi rst 10 lines of text:
$ head log_file


Peeking at the processes
When a program runs on the system, it’s referred to as a process
